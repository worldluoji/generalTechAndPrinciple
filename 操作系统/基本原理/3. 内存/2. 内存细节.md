# 内存细节
## 1.  Linux内存类型
Linux 的各个模块都需要内存，比如内核需要分配内存给页表，内核栈，还有 slab，也就是内核各种数据结构的 Cache Pool；

用户态进程里的堆内存和栈的内存，共享库的内存，还有文件读写的 Page Cache。

与用户态相关的两个内存：
- 1）RSS: RSS 是 Resident Set Size 的缩写，简单来说它就是指进程真正申请到物理页面的内存大小。
对于进程来说，RSS 内存包含了进程的代码段内存，栈内存，堆内存，共享库的内存, 这些内存是进程运行所必须的。我们通过 malloc/memset 得到的内存，就是属于堆内存。在 RSS 里的内存，大部分都是没有对应磁盘文件的内存，比如用 malloc() 申请得到的内存，这种内存也被称为匿名内存（Anonymous memory）。
- 2）Page cache: 如果进程对磁盘上的文件做了读写操作，Linux还会分配内存，把磁盘上读写到的页面存放在内存中，这部分的内存就是 Page Cache。
  
在 Linux 系统里只要有空闲的内存，系统就会自动地把读写过的磁盘文件页面放入到 Page Cache 里。

Linux 的内存管理有一种内存页面回收机制（page frame reclaim），会根据系统里空闲物理内存是否低于某个阈值（wartermark），来决定是否启动内存的回收。
内存回收的算法会根据不同类型的内存以及内存的最近最少用原则，就是 LRU（Least Recently Used）算法决定哪些内存页面先被释放。因为 Page Cache 的内存页面只是起到 Cache 作用，自然是会被优先释放的。它的目的是为了提高磁盘文件的读写性能。

Memory Cgroup 只是统计了 RSS 和 Page Cache 这两部分的内存。

<br>

## 2. Swap 空间
简单来说它就是就是一块磁盘空间。当内存写满的时候，就可以把内存中不常用的数据暂时写到这个Swap 空间上。
这样一来，内存空间就可以释放出来，用来满足新的内存申请的需求。
应对一些瞬时突发的内存增大需求，不至于因为内存一时不够而触发 OOM Killer，导致进程被杀死。

swappiness(/proc/sys/vm/swappiness):  可以决定系统将会有多频繁地使用交换分区。
一个较高的值会使得内核更频繁地使用交换分区，而一个较低的取值，则代表着内核会尽量避免使用交换分区。swappiness 的取值范围是 0–100，缺省值 60。

它不是一个百分比，更像是一个权重。它是用来定义 Page Cache 内存和匿名内存的释放的一个比例。
- 第一种情况，当 swappiness 的值是 100 的时候，匿名内存和 Page Cache 内存的释放比例就是 100: 100，也就是等比例释放了。
- 第二种情况，就是 swappiness 缺省值是 60 的时候，匿名内存和 Page Cache 内存的释放比例就是 60 : 140，Page Cache 内存的释放要优先于匿名内存。
- 第三种情况，swappiness = 0。当空闲内存少于内存一个 zone 的"high water mark"中的值的时候，Linux 还是会做内存交换，也就是把匿名内存写入到 Swap 空间后释放内存。在这里 zone 是 Linux 划分物理内存的一个区域，里面有 3 个水位线（water mark），水位线可以用来警示空闲内存的紧张程度。

总结一下：
swappiness 的取值范围在 0 到 100，值为 100 的时候系统平等回收匿名内存和 Page Cache 内存；一般缺省值为 60，就是优先回收 Page Cache；即使 swappiness 为 0，也不能完全禁止 Swap 分区的使用，就是说在内存紧张的时候，也会使用 Swap 来回收匿名内存。
需要你留意的时：对于容器来说有一点区别，当 设置memory.swappiness = 0 的时候，对匿名页的回收是始终禁止的，也就是容器始终都不会使用 Swap 空间。

<br>

## 3. Linux两种IO模式
- Direct I/O 模式，用户进程如果要写磁盘文件，就会通过 Linux 内核的文件系统层 (filesystem) -> 块设备层 (block layer) -> 磁盘驱动 -> 磁盘硬件，这样一路下去写入磁盘。
- Buffered I/O 模式，那么用户进程只是把文件数据写到内存中（Page Cache）就返回了，而 Linux 内核自己有线程会把内存中的数据再写入到磁盘中。在 Linux 里，由于考虑到性能问题，绝大多数的应用都会使用 Buffered I/O 模式。

<br>

## 4. dirty pages
而这些写入了数据的内存页面Page Cache，在它们没有被写入到磁盘文件之前，就被叫作 dirty pages。
我们可以设定一个比值 A，A  =  dirty pages 的内存 / 节点可用内存 * 100%。

1) dirty_background_ratio，缺省是 10%。如果比值 A 大于 dirty_background_ratio 的话，比如大于默认的 10%，内核 flush 线程就会把 dirty pages 刷到磁盘里。
2) dirty_background_bytes，它和 dirty_background_ratio 作用相同。区别只是 dirty_background_bytes 是具体的字节数，它用来定义的是 dirty pages 内存的临界值，而不是比例值。
这里你还要注意，dirty_background_ratio 和 dirty_background_bytes 只有一个可以起作用，如果你给其中一个赋值之后，另外一个参数就归 0 了。
3) dirty_ratio，缺省是 20%。如果比值 A，大于参数 dirty_ratio 的值，比如大于默认设置的 20%，这时候正在执行 Buffered I/O 写文件的进程就会被阻塞住，直到它写的数据页面都写到磁盘为止。
4) 第四个参数 dirty_bytes 与 dirty_ratio 相对应，它们的关系和 dirty_background_ratio 与 dirty_background_bytes 一样。我们给其中一个赋值后，另一个就会归零。
5) dirty_writeback_centisecs，这个参数的值是个时间值，以百分之一秒为单位，缺省值是 500，也就是 5 秒钟。它表示每 5 秒钟会唤醒内核的 flush 线程来处理 dirty pages。
6) dirty_expire_centisecs，这个参数的值也是一个时间值，以百分之一秒为单位，缺省值是 3000，也就是 30 秒钟。它定义了 dirty page 在内存中存放的最长时间，如果一个 dirty page 超过这里定义的时间，那么内核的 flush 线程也会把这个页面写入磁盘。

进程写操作上的时间波动，只有可能是因为 dirty pages 的数量很多，已经达到了第三个参数 dirty_ratio 的值。这时执行写文件功能的进程就会被暂停，直到写文件的操作将数据页面写入磁盘，写文件的进程才能继续运行，所以进程里一次写文件数据块的操作时间会增加。

写数据到 Page Cache 的时候，需要不断地去释放原有的页面，这个时间开销是最大的。造成容器中 Buffered I/O write() 不稳定的原因，正是容器在限制内存之后，Page Cache 的数量较小并且不断申请释放。
其实这个问题也提醒了我们：在对容器做 Memory Cgroup 限制内存大小的时候，不仅要考虑容器中进程实际使用的内存量，还要考虑容器中程序 I/O 的量，合理预留足够的内存作为 Buffered I/O 的 Page Cache。

<br>

## 5. OOM killer
在 Linux 系统里如果内存不足时，就需要杀死一个正在运行的进程来释放一些内存。

Linux 允许进程在申请内存的时候是 overcommit 的，这是什么意思呢？就是说允许进程申请超过实际物理内存上限的内存。

这是因为 malloc() 申请的是内存的虚拟地址，系统只是给了程序一个地址范围，由于没有写入数据，所以程序并没有得到真正的物理内存。物理内存只有程序真的往这个地址写入数据的时候，才会分配给程序。

在 Linux 内核里有一个 oom_badness() 函数，就是它定义了选择进程是否被OOM killer的标准：
- 第一，进程已经使用的物理内存页面数。
- 第二，每个进程的 OOM 校准值 oom_score_adj。在 /proc 文件系统中，每个进程都有一个 /proc//oom_score_adj 的接口文件。我们可以在这个文件中输入 -1000 到 1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。
```
adj = (long)p->signal->oom_score_adj;
points = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) + mm_pgtables_bytes(p->mm) / PAGE_SIZE;
adj *= totalpages / 1000;
points += adj;
```
用系统总的可用页面数，去乘以 OOM 校准值 oom_score_adj，再加上进程已经使用的物理页面数，计算出来的值越大，那么这个进程被 OOM Kill 的几率也就越大。

<br>

## 6. 内存和CPU的交互
CPU和内存来来回回传数据，靠的都是总线。 其实总线上主要有两类数据，一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线（Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）。

<br>

## 7. free -m
`free -m` 是一个在类Unix系统（如Linux）中常用的命令，用于显示系统的内存使用情况，这里的 `-m` 参数表示以兆字节（MB）为单位显示内存大小，使得数据更易于阅读。这个命令对于系统管理员监控和诊断内存相关问题非常有用。

free -h （human-readable）: 加上了 -h 选项后，命令会以更人性化的方式显示内存大小，自动选择最合适的单位（通常是 K, M, G, T 等）来表示内存用量。这意味着无论内存总量多大，输出都会以易于阅读的单位展示，比如几百GB的内存会显示为几十G，而不是以字节数或KB、MB等较小单位显示。这对于快速理解系统的内存状态特别有帮助，尤其是当面对不同规模的系统时，无需手动换算单位。

### 输出结构

`free -m` 的输出通常分为几个部分，主要关注的是物理内存（Mem）和交换空间（Swap）的使用情况。

#### Mem（物理内存）
- **total**: 物理内存的总大小。
- **used**: 实际使用的内存大小，包括应用程序占用的内存、内核缓冲区和缓存等。
- **free**: 完全未被使用的内存。
- **shared**: 多个进程之间共享的内存部分，现代Linux系统中这部分通常很小，有时为0。
- **buffers**: 用于存储文件系统的块的临时缓冲区，这部分内存可以快速释放给其他需要的应用程序。
- **cached**: 文件系统的页缓存，同样，这部分内存也可以快速回收给需要的应用程序。Linux内核会积极利用空闲内存作为文件和目录的缓存，以加速磁盘访问速度。
- **available**: 可用内存，即应用程序可立即使用的内存总量。这个值考虑了buffers和cache，因此通常比free更大，更准确地反映了系统当前的实际可用内存。

### 实例解析
假设输出如下：
```
              total        used        free      shared  buff/cache   available
Mem:           7864         2000        1500          12        4364        5796
Swap:          2047           0        2047
```
- **物理内存**：总内存7864MB，已使用2000MB，空闲1500MB，共享内存12MB（通常较小），buff/cache一共为4364MB, 还可以被应用程序使用的内存为5796MB。
- **交换空间**：总大小2047MB，未被使用，表明目前没有内存被换出到磁盘上。


## buffer和Cache的区别
在Linux系统中，`buff`（缓冲区）和`cache`（缓存）都是用于提高系统性能的内存使用方式，但它们各自服务于不同的目的：

### Buffer（缓冲区）
- **用途**: 主要用于存储即将被写入磁盘的数据。当一个程序需要将数据写入到磁盘时，这些数据会先被存储在缓冲区中。这样做有几个好处：减少实际写操作的次数，优化磁盘I/O性能，以及允许数据以块为单位更高效地写入。
- **类型**: 这通常指的是`Buffer cache`，它是内核缓冲区的一部分，对应于`/proc/meminfo`中的`Buffers`值。
- **特点**: 缓冲区更多地涉及到文件系统的写操作，帮助平滑写入过程，减少I/O等待时间。

### Cache（缓存）
- **用途**: 主要用于存储从磁盘读取的数据副本。当一个文件或磁盘块被访问后，其内容可能会被加载到缓存中，这样如果系统随后再次请求相同的数据，就可以直接从速度更快的内存中读取，而不需要再次访问较慢的磁盘。这显著提高了数据读取速度。
- **类型**: 这通常指的是`Page cache`（页面缓存），它是内核页缓存的一部分，对应于`/proc/meminfo`中的`Cached`与`SReclaimable`之和。
- **特点**: 页面缓存侧重于提升读取性能，减少对磁盘的重复访问，特别是在文件系统活动频繁的系统中。

尽管`buffer`和`cache`都是作为提高I/O效率的机制，但它们处理的操作类型不同：缓冲区主要与写操作相关，而缓存则主要与读操作相关。Linux系统会动态管理这两部分内存的使用，根据需要自动分配和释放，以优化整体系统性能。在`free`命令的输出中，`buff/cache`的合计值通常体现了系统为了提高I/O效率而暂时使用的内存总量。当系统需要更多内存供应用程序使用时，这部分内存可以迅速被回收。