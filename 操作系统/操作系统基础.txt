1. 操作系统的内核态和用户态
内核：本质上是一种软件，用于控制计算机的硬件资源，包括CPU、存储资源、IO等。内核有自己的空间概念，成为内核空间。
用户态：即上层应用程序的活动空间，应用程序必须依赖于内核提供的资源。
系统调用：为上层应用能访问到内核资源，而供上层应用访问的接口。比如C语言的malloc、printf函数就是封装了一些系统调用，成为了内核和用户态之间的桥梁。

进程的虚拟地址空间总体分为用户空间和内核空间，低地址上的 3GB 属于用户空间，高地址的 1GB 是内核空间，这是基于安全上的考虑，用户程序只能访问用户空间，内核程序可以访问整个进程空间，并且只有内核可以直接访问各种硬件资源，比如磁盘和网卡。那用户程序需要访问这些硬件资源该怎么办呢？答案是通过系统调用，系统调用可以理解为内核实现的函数，比如应用程序要通过网卡接收数据，会调用 Socket 的 read 函数。

为什么程序不直接运行在内核态（这样还免去了用户态和内核态切换的消耗）？
如果应用程序直接在内核态运行，权限级别太高，出了问题会导致整个操作系统崩溃，所有才有了用户态核心态，算是一种隔离和容错吧。
例如，当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包，就需要暂停当前的运行，调用系统调用，接下来就轮到内核中的代码运行了。
如果不分用户态和内核态，可能在用户态，已经就把操作系统搞崩了。

用户空间上还有一个共享库和 mmap 映射区，Linux 提供了内存映射函数 mmap， 它可将文件内容映射到这个内存区域，用户通过读写这段内存，从而实现对文件的读取和修改，无需通过 read/write 系统调用来读写文件，省去了用户空间和内核空间之间的数据拷贝，Java 的 MappedByteBuffer 就是通过它来实现的；用户程序用到的系统共享库也是通过 mmap 映射到了这个区域。

2. 进程、僵尸进程和孤儿进程的区别
QQ 的二进制文件是静态的，称为程序（Program），而运行起来的 QQ，是不断进行的，称为进程（Process）。
在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

孤儿进程：一个进程退出，而它的一个或多个子进程还在运行，那么这些子进程就成为孤儿进程；
         孤儿进程将被init进程所收养，并由init线程完成对它们的状态收集工作

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，父进程因为没有调用wait或者waitpid获取子进程的状态信息，那么子进程的进程描述符仍然在系统中存在。
正常情况下，linux操作系统，子进程通过父进程创建，子进程的结束和父进程的运行是一个异步的过程，父进程无法预测子进程什么时候结束，当一个进程完成工作退出时，会释放内存等资源，但是不会将进程号、退出状态、运行时间等状态清除。子进程会向父进程发出SIGCHLD信号，父进程会调用wait或waitpid系统调用取得子进程的最终状态，才把前面的状态清除。

3. init进程
它是内核初始化完启动的第一个进程，这个进程会创建相应的系统服务，从而使系统正常运行

4. fork后发生了什么？
对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用execve来执行另一个程序，这个时候，子进程和父进程就彻底分道扬镳了，也就产生了一个分支（fork）了。
这样主要是因为一个父进程可以有多个子进程，这里父进程如果不获取子进程的进程ID，以后就不好获取了。 
子进程可以通过getpid()获取自己的进程ID，通过getppid()获取父进程的ID。

5. Linux程序执行
操作系统要运行一个可执行程序，首先要将程序文件加载到内存，然后 CPU 去读取和执行程序指令，而一个进程就是“一次程序的运行过程”，内核会给每一个进程创建一个名为task_struct的数据结构，而内核也是一段程序，系统启动时就被加载到内存中了。

我在开始提到的task_struct结构体本身是分配在内核空间，它的vm_struct成员变量保存了各内存区域的起始和终止地址，此外task_struct中还保存了进程的其他信息，比如进程号、打开的文件、创建的 Socket 以及 CPU 运行上下文等。

在 Linux 中，线程是一个轻量级的进程，轻量级说的是线程只是一个CPU 调度单元，因此线程有自己的task_struct结构体和运行栈区，但是线程的其他资源都是跟父进程共用的，比如虚拟地址空间、打开的文件和 Socket 等。

所谓调度就是在可运行进程列表中选择一个进程，再从 CPU 列表中选择一个可用的 CPU，将进程的上下文恢复到这个 CPU 的寄存器中，然后执行进程上下文指定的下一条指令。

而阻塞的本质就是将进程的task_struct移出运行队列，添加到等待队列，并且将进程的状态的置为TASK_UNINTERRUPTIBLE或者TASK_INTERRUPTIBLE，重新触发一次 CPU 调度让出 CPU。 那线程怎么唤醒呢？线程在加入到等待队列的同时向内核注册了一个回调函数，告诉内核我在等待这个 Socket 上的数据，如果数据到了就唤醒我。


6. CPU和内存来来回回传数据，靠的都是总线。 其实总线上主要有两类数据，一个是地址数据，也就是我想拿内存中哪个位置的数据，这类总线叫地址总线（Address Bus）；另一类是真正的数据，这类总线叫数据总线（Data Bus）。


7. Linux的0号进程
在操作系统里面，先要有个创始进程，有一行指令 set_task_stack_end_magic(&init_task)。这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 0 号进程。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。

8. Linux的1号进程
用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建的第二个进程，这个是 1 号进程
1 号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程，这意味着这个公司把一个老板独立完成的制度，变成了可以交付他人完成的制度。这个 1 号进程就相当于老板带了一个大徒弟，有了第一个，就有第二个，后面大徒弟开枝散叶，带了很多徒弟，形成一棵进程树。

9. Linux的2号进程
从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目包含很多资源，例如会议室、资料库等。这些东西都属于这个项目，但是这个项目需要人去执行。有多个人并行执行不同的部分，这就叫多线程（Multithreading）。如果只有一个人，那它就是这个项目的主线程。但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。这些在进程的那一章节，我会更加详细地讲。
kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) 又一次使用 kernel_thread 函数创建进程，就是2号进程，这里的函数 kthreadd负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。

10. Linux 里有一个特点，那就是一切皆文件。
1）一个进程的输出可以作为另一个进程的输入，这种方式称为管道，管道也是一个文件。
2）进程可以通过网络和其他进程进行通信，建立的 Socket，也是一个文件。
3）进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，还是一系列文件。
每个文件，Linux 都会分配一个文件描述符（File Descriptor），这是一个整数。
有了这个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面。

11. 当进程遇到异常情况，例如进程中断，做到一半不做了。这时候就需要发送一个信号（Signal）给进程
对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过sigaction系统调用，注册一个信号处理函数。