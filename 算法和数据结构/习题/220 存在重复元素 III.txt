给你一个整数数组 nums 和两个整数?k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得?abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。

思路：
暴力求解时间复杂通过不了。
可以使用滑动窗口的思路，维护一个大小为 k 的滑动窗口，每次遍历到元素 x 时，滑动窗口中包含元素 x 前面的最多 k 个元素，我们检查窗口中是否存在元素落在区间 [x - t, x + t] 中即可。
当我们希望判断滑动窗口中是否存在某个数 y落在区间 [x - t, x + t] 中，只需要判断滑动窗口中所有大于等于 x - t 的元素中的最小元素是否小于等于 x + t即可。

class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        int n = nums.length;
        // 少于2个数，不能存在两个不同的下标，因此一定为false
        if (n < 2 || k == 0) {
            return false;
        }
        TreeSet<Long> set = new TreeSet<>();
        for (int i = 0; i < n; i++) {
            long x = (long)nums[i];
            // ceiling方法用来返回在此设定为大于或等于给定的元素的最小元素
            Long val = set.ceiling(x - t);
            if (val != null && val <= (x + t)) {
                return true;
            }
            set.add(x);
            if (i >= k) {
                set.remove((long)nums[i - k]);
            }
        }   
        return false;     
    }
}
