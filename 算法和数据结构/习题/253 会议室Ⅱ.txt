给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

示例 1：
输入：intervals = [[0,30],[5,10],[15,20]]
输出：2

思路：
理解成上下车问题会比较容易解决，不用在意是谁上车还是下车，只需要注意什么时候上下车就可以。 以第一个示例来说：

↑    ↑    ↓     ↑      ↓             ↓
0----5----10----15-----20-----------30-->
这样可以把上车和下车的时间分成两组，通过两个指针滑动的方式，判断同时在车上的最大数就可以了。

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if (intervals.length == 1) {
            return 1;
        }

        Arrays.sort(intervals, (int[] o1, int[] o2) -> o1[0] - o2[0]);

        int count = 1;
        int max = count;
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        queue.offer(intervals[0][1]);
        for (int i = 1; i < intervals.length; i++) {
            count++;
            if (queue.peek() != null && queue.peek() <= intervals[i][0]) {
                 Integer num = queue.peek();
                 while(num != null && num <= intervals[i][0]) {
                    count--;
                    queue.remove(num);
                    num = queue.peek();
                }
            }
            
            queue.offer(intervals[i][1]);
            
            if (count > max) {
                max = count;
            }
        }
        return max;
    }
}