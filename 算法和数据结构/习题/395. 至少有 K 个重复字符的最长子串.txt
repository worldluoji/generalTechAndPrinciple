给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串，?要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

示例 1：
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。

思路：
先整体考虑，如果某个字符在整个字符串中的出现次数 < k，那它一定不会出现在合法子串中。
s: aaabbaa,k: 3，b 只出现 2 次，它肯定不会出现在合法子串中，要到它的两侧找。
考察aaa和aa，变成一个规模较小的子问题，递归去求aaa和aa中合法子串的最长长度。
当递归到子问题的规模足够小，即，子串的长度小于 k，即便子串的字符都相同，字符的出现次数也小于 k，所以没有合法子串，返回 0


func longestSubstring(s string, k int) int {
    n := len(s)
    if k == 1 {
        return n
    } else if (k > n) {
        return 0
    }
    return dfs(s, k)
}

func dfs(ss string, k int) int {
    n := len(ss)
    if n < k {
        return 0
    }
    mp := map[uint8]int{}
    for _, s := range ss {
	mp[uint8(s)]++
    }
    max := 0
    matchAll := true
    for i, s := range ss {
        if mp[uint8(s)] < k {
            matchAll = false
            var max1 = 0
            var max2 = 0
            if i > 0 {
                max1 = dfs(ss[0:i], k)
            }
            if i+1 < n {
                max2 = dfs(ss[i+1:], k)
            }
            if max1 > max {
                max = max1
            }
            if max2 > max {
                max = max2
            }
            break
        }
    }
    if matchAll {
        return n
    }
    return max
}