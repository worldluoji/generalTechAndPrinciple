前置知识：
TCP位于传输层，用于保证数据的可靠性，并通过TCP的端口号找到对应的进程；IP则在网络层。 两台主机A和B通信， 通过IP先找到主机在哪里。 

1. TCP的滑动窗口和拥塞窗口的区别
1）滑动窗口：表征接收端的接收能力，针对收发双方而言
TCP头中有一个window字段，当接收端回ACK时，会告诉发送端自己还有多少缓冲区可以接收数据，
发送端就根据接收端缓冲区的大小来调整发送的数据量，从而接收端不会处理不过来。

在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK 的包，即便后来的包都到了，放在缓存里面，
窗口也不能右移，因为 TCP 的 ACK 机制是基于序列号的累计应答，一旦 ACK 了一个序列号，就说明前面的都到了，
所以只要前面的没到，后面的到了也不能 ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。
(累计应答，有可能后面先到的包因为等待前面的包的到达，而没有给对端发送ACK消息。
导致对端会认为包丢失了，而对端重新发送相同的数据包)

2）拥塞窗口：表征中间设备、整个网络的传输能力

几种拥塞控制方法
    慢启动( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )

慢启动和拥塞避免
    发送方维持一个拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。
    发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。
    但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

    慢启动算法：当主机开始发送数据时，如果立即将大量数据注入到网络，那么就有可能引起网络拥塞，
    因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，
    也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。
    而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

快重传和快恢复
    如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。
    这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢启动算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。
    快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），
    而不要等到自己发送数据时才进行捎带确认。

2. 分片丢包怎么办？
 UDP: 有CRC校验，不完整就丢了
 TCP: 有重传机制保证
 TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

3. 不同的连接连到同一个端口
A -> C 发100
B -> C 发200
C recv(300)收到多少？A->C和B->C是不同的TCP连接，同一个socket进行listen的工作，但是是不同的socket进行处理，每个socket都有自己的接收和发送缓冲区
UDP则来一个报文处理一个

4. TCP粘包和半包
一个发送可能被多次接收，多个发送可能被一次接收，TCP又是流式协议，所以可能会导致粘包和半包。

1). 粘包 
• 发送方每次写入数据 <  套接字缓冲区大小。 
• 接收方读取套接字缓冲区数据不够及时。 
比如一次发了AAA、BBB两个独立的包，但是AAA+BBB才达到缓冲区大小，这时候才会发送，接收端可能收到 AAABBB 或者BBBAAA（网络问题，可能后发的包先到了）粘在一起的包。
解决办法：a.设置PUSH标识位，立即发出；b.加自定义包头、包尾的检查位，程序进行控制。

2). 半包
• 发送方写入数据 >  套接字缓冲区大小
• 发送的数据大于协议的MTU（Maximum Transmission Unit，大传输单元），必须拆包
拆包就会导致上面的粘包问题。

5. 为什么TCP要三次握手
• 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。
后来收到了确认，建立了连接。
数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

6. 为什么TCP要四次挥手
TCP是全双工的，两边都要关闭了才算关闭，而且一方的关闭也要确认对方确认。
client先发送FIN告知是server我已经完成数据发送了，server回复ack来确定我知道了。这样一个流程，就关闭了client的发送信息通道。但是还可以接收来自server方的数据。
server此时已经知道接收不到client的数据了，但是还可以给它发送数据。如果server也没有啥数据要发送给对方了，server也会以FIN标志位发送一个信息给client，client接到后，也会传递一个ack表示知道了。这样子，双方都完成了关闭。

7. 为什么要有time wait状态等待2MSL呢？
MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期，超过这个时间，包则被丢弃。

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。等待2MSL就是为了确保服务器能收到该报文，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启2MSL计时。否则服务器端这个端口可能一直占着得不到关闭。

还有一个异常情况就是，服务器超过了 2MSL 的时间，依然没有收到客户端发送的ACK，怎么办呢？按照 TCP 的原理，服务器端当然还会重发 FIN，这个时候客户端 再收到这个包之后，就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送RST，服务器就知道客户端早就跑了。


8. 为什么有了IP还要有Mac地址
1）在一个局域网内，MAC地址是不能重复的。 MAC 地址更像是身份证，是一个唯一的标识。
它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。
从硬件角度，保证不同的网卡有不同的标识。而现在常用的动态分配IP（DHCP）地址是会变化的，
你怎么知道你还是你，就是需要Mac这个唯一标识了。
2）一个网络包要从一个地方传到另一个地方，除了要有身份证以外，还需要有定位功能，即知道对方在哪里。 
而有“在哪里”属性的 IP 地址，才是有远程定位功能的。
如果我们只用 MAC 地址的话，我们会发现路由器需要记住每个 MAC 地址所在的子网是哪一个（不然每一次收到数据包的时候路由器都要重新满世界地去找这个 MAC 地址的位置）。
而世界上有2^48个 MAC 地址，这就意味着即使我们给每个 MAC 地址只留 1 字节的储存空间，每个路由器也需要 256 TB 的内存！这显然是不可能实现的。

9. 无类型域间选路（CIDR）
10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。

10. 网关
不同网段之间的主机通信就要通过网关。
不改变IP地址的网关，我们称为转发网关，即直接将进入网关的包依据路由表转发到下一个节点；
不同局域网的IP地址可以相同吗？
改变IP地址的网关，我们称为NAT网关。比如，局域网之间没有商量过，各定各的网段，因而 IP 段冲突了。
这时候就需要使用NAT网关。
目标服务器 B 在国际上要有一个国际的身份，我们给它一个 192.168.56.2。
在网关 B 上，我们记下来，国际身份 192.168.56.2 对应国内身份 192.168.1.101。凡是要访问 192.168.56.2，都转成 192.168.1.101

11. TCP如何处理丢包的？
为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）。
比如6，7，8，9都收到了，回一个9的ACK，就知道前面的包都收到了。
TCP的策略是超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。
还有一个快速重传的机制：当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。
例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。

12. 只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。
所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。

13. 什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。
那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。