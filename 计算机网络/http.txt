1. http常见状态码码
200 响应成功
3xx 重定向
4xx 客户端错误，比如404为找不到资源，400为参数请求错误
5xx 服务器端错误

2. WSGI 网络服务网关接口
开发者实现一个函数就能响应http请求，使开发者不需要去关注TCP连接、以及http响应的格式，即不需要开发者去解析底层协议

3. HTTP 1.1 的请求报文大概分为三大部分。第一部分是请求行，第二部分是请求的首部，第三部分才是请求的正文实体。
1) 在请求行中，主要是URL和方法（GET、POST、PUT、DELETE）
2) 首部字段，
Accept-Charset，表示客户端可以接受的字符集。防止传过来的是另外的字符集，从而导致出现乱码。
Content-Type 是指正文的格式，比如我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。
再比如text/html表示网页。浏览器根据这个字段判定是网页，图片，视频还是音乐。
Cache-control 是用来控制缓存的。当客户端发送的请求中包含 max-age 指令时，
如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；
当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。
If-Modified-Since 也是一个关于缓存的。
也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；
如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。

4. HTTP 1.1的返回报文格式
1） 状态码，比如200，400，404，500等
2） 首部字段
Retry-After 表示，告诉客户端应该在多长时间以后再次尝试一下。“503 错误”是说“服务暂时不再和这个值配合使用”。
Content-Type，表示返回的是 HTML，还是 JSON。
3）HTTP 1.1缺点
HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，
每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。


5. HTTP 2.0
1）HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key-value 在两端建立一个索引表，
对相同的头只发送索引表中的索引。
2）HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，
而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。
3）HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。
常见的帧有 Header 帧，用于传输 Header 内容，并且会开启一个新的流。
再就是 Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。
通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。
这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。

因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。
当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。
虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，
然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。

6. QUIC协议
1）自定义连接标志
基于 UDP，就可以在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，
而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，
所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。

2）自定义重传机制
QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。
例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；
如果返回的 ACK  100，就是对第一个包的响应。如果返回 ACK  101 就是对第二个包的响应，
往返时间 RTT 计算相对准确。
怎么知道包 100 和包 101 发送的是同样的内容呢？QUIC 定义了一个 offset 概念。
QUIC 既然是面向连接的，也就像 TCP 一样，是一个数据流，发送的数据在这个数据流里面有个偏移量 offset，
可以通过 offset 查看数据发送到了哪里，这样只要这个 offset 的包没有来，就要重发；
如果来了，按照 offset 拼接，还是能够拼成一个流。

3）无阻塞的多路复用
同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。
但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。
这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，
虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。

4）自定义流量控制
QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，
中间的空档会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，
从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。