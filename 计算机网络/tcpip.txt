1. TCP的滑动窗口和拥塞窗口的区别
1）滑动窗口：表征接收端的接收能力，针对收发双方而言
TCP头中有一个window字段，当接受端回ACK时，会告诉发送端自己还有多少缓冲区可以接收数据，
发送端就根据接收端缓冲区的大小来调整发送的数据量，从而接收端不会处理不过来。

2）拥塞窗口：表征中间设备、整个网络的传输能力

几种拥塞控制方法
    慢启动( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )

慢启动和拥塞避免
    发送方维持一个拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。
    发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
    慢启动算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。

快重传和快恢复
    如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢启动算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。
    快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认

2. 分片丢包怎么办？
 UDP: 有CRC校验，不完整就丢了
 TCP: 有重传机制保证

3. 不同的连接连到同一个端口
A -> C 发100
B -> C 发200
C recv(300)收到多少？A->C和B->C是不同的TCP连接，不同的socket进程处理，每个socket都有自己的接受和发送缓冲区
UDP则来一个报文处理一个

4. TCP粘包和半包
一个发送可能被多次接收，多个发送可能被一次接收，TCP又是流式协议，所以可能会导致粘包和半包。

1). 粘包 
• 发送方每次写入数据 <  套接字缓冲区大小。 
• 接收方读取套接字缓冲区数据不够及时。 
比如一次发了AAA、BBB两个独立的包，但是AAA+BBB才达到缓冲区大小，这时候才会发送，接收端可能收到 AAABBB 或者BBBAAA（网络问题，可能后发的包先到了）粘在一起的包。
解决办法：a.设置PUSH标识位，立即发出；b.加自定义包头、包尾的检查位，程序进行控制。

2). 半包
• 发送方写入数据 >  套接字缓冲区大小
• 发送的数据大于协议的MTU（Maximum Transmission Unit，大传输单元），必须拆包
拆包就会导致上面的粘包问题。

5. 为什么TCP要三次握手
• 防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。
后来收到了确认，建立了连接。
数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

6. 为什么TCP要四次挥手
TCP是全双工的，两边都要关闭了才算关闭，而且一方的关闭也要确认对方确认。
client先发送FIN告知是server我已经完成数据发送了，server回复ack来确定我知道了。这样一个流程，就关闭了client的发送信息通道。但是还可以接收来自server方的数据。
server此时已经知道接收不到client的数据了，但是还可以给它发送数据。如果server也没有啥数据要发送给对方了，server也会以FIN标志位发送一个信息给client，client接到后，也会传递一个ack表示知道了。这样子，双方都完成了关闭。

7. 为什么要有time wait状态等待2ML呢？
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。等待2ML就是为了确保服务器能收到该报文，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启2MSL计时。否则服务器端这个端口可能一直占着得不到关闭。
MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期，超过这个时间，包则被丢弃。



