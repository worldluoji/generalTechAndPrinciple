# json-rpc vs grpc.md
**JSON-RPC 是一种动态协议，它依赖于运行时（runtime）的约定而非编译前的严格定义，而 gRPC 是一种静态协议，强制要求严格的、机器可验证的接口契约（Contract）。**

下面我们从几个关键维度进行详细对比，来解释为什么 JSON-RPC 不需要像 gRPC 那样的 `.proto` 文件。

---

### 1. 核心哲学与设计目标

| 特性 | JSON-RPC | gRPC |
| :--- | :--- | :--- |
| **核心目标** | **简单、灵活、易于实现和调试**。 | **高性能、强类型、跨语言、标准化**。 |
| **哲学** | **动态（Dynamic）**。相信调用双方只要遵守简单的 JSON 格式和口头/文档约定即可工作。 | **静态（Static）**。相信接口必须被明确定义和强制遵守，以确保正确性和可靠性。 |
| **类比** | **动态类型语言**（如 JavaScript, Python）。写起来快，更灵活，但运行时可能出错。 | **静态类型语言**（如 Go, Java）。写之前要多定义，但编译器能提前发现许多错误，更可靠。 |

`.proto` 文件是 gRPC **静态、强类型**哲学的基石，而 JSON-RPC 的 **动态、灵活性** 哲学则主动放弃了这种约束。

---

### 2. 接口定义与契约 (Interface Definition & Contract)

| | JSON-RPC | gRPC |
| :--- | :--- | :--- |
| **契约形式** | **隐性契约**。通常通过人类可读的文档（如 Markdown、Wiki）或口头约定来描述方法名、参数和返回值。机器无法自动验证。 | **显性契约**。通过 `.proto` 文件明确定义服务、方法、参数和消息格式。这是机器可读、可验证的单一事实来源。 |
| **验证时机** | **运行时**。只有在实际调用时，如果参数错误或方法不存在，才会通过错误响应发现問題。 | **编译时**。在代码编译阶段，就可以利用生成的代码发现类型不匹配等错误，大大提前了错误发现的时间。 |

*   **JSON-RPC**：就像一个朋友给你打电话说：“嘿，帮我算个数，把 5 和 3 加起来。” 你们之间依靠的是**语言和常识**（隐性契约）。如果他说“把苹果和 3 加起来”，你只能在听到的时候才发现问题。
*   **gRPC**：就像你填写一份正式的申请表（`.proto`文件），上面明确写着“字段A：整数，字段B：整数”。任何不按申请表填写的内容都会被前台直接拒收（编译错误）。

gRPC **需要** `.proto` 文件来生成这份严格的“申请表”。JSON-RPC 则认为“打个电话说一声”就够了。

---

### 3. 数据序列化方式 (Data Serialization)

| | JSON-RPC | gRPC |
| :--- | :--- | :--- |
| **序列化格式** | **JSON (JavaScript Object Notation)** | **Protocol Buffers (Protobuf)** |
| **特点** | **人类可读**、自描述、灵活、但冗余（文本格式）、解析效率较低。 | **二进制编码**、高效、紧凑、序列化/反序列化速度快、但人类不可读。 |

*   **JSON-RPC**：使用 JSON。JSON 本身是动态的，一个对象包含哪些字段、是什么类型，都需要在运行时解析才能知道。因此，它不需要一个预先的定义文件。
*   **gRPC**：使用 Protobuf。Protobuf 为了达到极高的编码和解码效率，**必须**依赖 `.proto` 文件作为编/解码的蓝图。发送方和接收方都必须严格按照这个蓝图来操作，才能正确地将数据编码成二进制流或从二进制流中解码出来。

Protobuf 的**高性能**和**跨语言一致性**优势，正是建立在牺牲 JSON 的**灵活性和人类可读性**，并强制使用 `.proto` 文件这一基础之上的。

---

### 4. 代码生成 (Code Generation)

| | JSON-RPC | gRPC |
| :--- | :--- | :--- |
| **代码生成** | **通常没有**。开发者需要手动编写调用请求和解析响应的代码。 | **核心功能**。通过 `protoc` 编译器读取 `.proto` 文件，自动生成客户端和服务端的**桩代码（Stubs）**。 |

gRPC 的代码生成是它强大功能的核心。这个流程**必须**有 `.proto` 文件作为输入：
**`.proto`文件 -> `protoc`编译器 -> 生成客户端/服务端代码（Java, Go, Python, C++ ...）**

生成的代码提供了强类型的 API，使得调用远程方法就像调用本地方法一样简单，并且避免了大量的模板代码。JSON-RPC 没有这个过程，因此也不需要 `.proto` 文件。

---

### 总结对比表

| 特性 | JSON-RPC | gRPC |
| :--- | :--- | :--- |
| **接口定义** | 无强制，依赖文档（人治） | 强制，`.proto` 文件（法治） |
| **类型系统** | 动态，弱类型 | 静态，强类型 |
| **序列化格式** | JSON（文本，可读） | Protobuf（二进制，高效） |
| **代码生成** | 无 | 有，是核心功能 |
| **性能** | 较低 | 非常高 |
| **开发体验** | 灵活，简单，易调试 | 严谨，安全，自动化程度高 |
| **适用场景** | 内部快速原型、简单API、对性能要求不高的场景 | 微服务、高性能API、跨语言大型项目、需要严格接口约束的场景 |

所以，**JSON-RPC 不需要 `.proto` 文件，是因为它的设计选择了一条更简单、更灵活的道路，用运行时的不确定性和人工维护的成本，换取了开发的便捷性。** 而 **gRPC 通过引入 `.proto` 文件，增加了一定的前期复杂度，但换来了高性能、高可靠性、自动化和极强的跨语言能力。**

两者没有绝对的好坏，只有是否适合你的具体场景。